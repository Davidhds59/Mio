<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Ver Serie</title>
  <link rel="stylesheet" href="https://zonaaps-player.xyz/style.css">  
  <script src="https://cdn.jwplayer.com/libraries/IDzF9Zmk.js"></script>
</head>
<body>
  <header class="site-header">
    <a href="index.html" class="back">← Volver</a>
    <h1 id="serie-title">Serie</h1>
  </header>
<br> <br> <br>
  <main class="serie-container">
    <!-- Info (póster + datos) - FIJO -->
    <section id="serie-info" class="serie-info"></section>

    <!-- Reproductor - FIJO -->
    <div id="player-wrapper" class="player-wrapper">
      <div id="player-container" class="player-container" style="position: relative;">
        <div id="myPlayer"></div>

        <!-- Overlay continuar / resume -->
        <div id="continue-overlay" style="
          display:none;
          position:absolute;
          inset:0;
          background:rgba(0,0,0,0.75);
          color:white;
          z-index:2000;
          display:flex;
          align-items:center;
          justify-content:center;
          flex-direction:column;
          text-align:center;
          padding:12px;
        ">
          <p id="continue-text" style="font-size:1rem;margin-bottom:10px;">¿Deseas continuar viendo desde donde lo dejaste?</p>
          <div style="display:flex;gap:12px;">
            <button id="continue-yes" style="padding:8px 16px;background:#00ff7f;border:none;border-radius:6px;color:#000;font-weight:bold;cursor:pointer;">Sí, continuar</button>
            <button id="continue-no" style="padding:8px 16px;background:#fff;border:none;border-radius:6px;color:#000;font-weight:bold;cursor:pointer;">No, empezar desde inicio</button>
          </div>
        </div>
      </div>
    </div>

    <!-- Panel inferior -->
    <div class="bottom-panel">
      <div class="season-selector">
        <label for="seasonSelect">Seleccionar temporada:</label>
        <select id="seasonSelect"></select>
      </div>

      <section id="episodes" class="episodes scrollable-list"></section>
    </div>
  </main>

 

<script>
const TMDB_API_KEY = 'cc5b94165972aa509a349161d13d4fc9';
const imageBase = 'https://image.tmdb.org/t/p/w500';
const imageBackdrop = 'https://image.tmdb.org/t/p/original';
const urlParams = new URLSearchParams(window.location.search);
const serieId = urlParams.get('id');
let seriesData = {};
let currentEpisodeKey = null; // clave única para guardar progreso (serieId-S{n}-E{m})
let playerInstance = null;
let lastSavedPosition = 0; // para fallback en unload

// Carga local (series.json) si existe
fetch('series.json')
  .then(r => r.json())
  .then(data => { seriesData = data; })
  .catch(()=>{ /* no fatal si no hay series.json */ });

/* UTIL: formatea segundos a mm:ss */
function formatTime(sec){
  sec = Math.floor(Number(sec) || 0);
  const m = Math.floor(sec/60);
  const s = sec%60;
  return `${m}:${s.toString().padStart(2,'0')}`;
}

/* Buscar info de la serie en TMDb */
async function fetchSerieInfo() {
  try {
    const res = await fetch(`https://api.themoviedb.org/3/tv/${serieId}?api_key=${TMDB_API_KEY}&language=es-ES`);
    const serie = await res.json();
    renderSerieInfo(serie);
    loadSeasons(serie);
  } catch (e) {
    console.error('Error cargando serie:', e);
  }
}

function renderSerieInfo(serie) {
  document.getElementById('serie-title').textContent = serie.name || 'Serie';
  if (serie.backdrop_path) {
    document.body.style.backgroundImage = `url(${imageBackdrop + serie.backdrop_path})`;
  }
  document.body.style.backgroundSize = "cover";
  document.body.style.backgroundPosition = "center";
  document.body.style.backgroundAttachment = "fixed";
  document.body.style.backgroundRepeat = "no-repeat";

  const container = document.getElementById('serie-info');
  const rating = serie.vote_average ? Math.round(serie.vote_average * 10) : 0;

  container.innerHTML = `
    <div class="info-overlay">
      <img src="${serie.poster_path ? imageBase + serie.poster_path : ''}" class="poster" alt="${serie.name || ''}">
      <div class="details">
        <h2>${serie.name || ''}</h2>
        <div class="rating-wrapper">
          <div class="rating-circle" style="--offset:${110 - (rating * 1.1)};">
            <svg>
              <circle class="bg" cx="14" cy="14" r="0"></circle>
              <circle class="progress" cx="14" cy="14" r="12"></circle>
            </svg>
            <span>${rating}%</span>
          </div>
        </div>
        <p class="tagline">${serie.tagline || ''}</p>
        <p class="overview">${serie.overview || 'Sin descripción disponible.'}</p>
        <p><strong>Primera emisión:</strong> ${serie.first_air_date || 'N/A'}</p>
        <p><strong>Géneros:</strong> ${(serie.genres || []).map(g => g.name).join(', ')}</p>
      </div>
    </div>
  `;
}

/* Carga las temporadas en el select. Si existe un 'last watched' para esta serie,
   muestra overlay preguntando si desea continuar donde lo dejó. */
function loadSeasons(serie) {
  const select = document.getElementById('seasonSelect');
  select.innerHTML = '<option value="">-- Selecciona una temporada --</option>';
  (serie.seasons || []).forEach(season => {
    if (season.season_number >= 0) {
      const opt = document.createElement('option');
      opt.value = season.season_number;
      opt.textContent = season.name || `Temporada ${season.season_number}`;
      select.appendChild(opt);
    }
  });

  select.addEventListener('change', () => {
    const num = select.value;
    if (num !== '') fetchSeasonEpisodes(num);
  });

  // Determinar primera temporada disponible
  const firstSeason = (serie.seasons && serie.seasons.length > 0) ? serie.seasons[0].season_number : null;

  // Revisar si hay progreso guardado para esta serie
  try {
    const lastRaw = localStorage.getItem(`${serieId}-last`);
    if (lastRaw) {
      const lastObj = JSON.parse(lastRaw);
      if (lastObj && lastObj.season != null && lastObj.episode != null && Number(lastObj.time) > 5) {
        // mostrar overlay global de "continuar última vez"
        const overlay = document.getElementById('continue-overlay');
        const text = document.getElementById('continue-text');
        text.textContent = `¿Deseas continuar la última vez desde Temporada ${lastObj.season} Episodio ${lastObj.episode} (${formatTime(lastObj.time)})?`;
        overlay.style.display = 'flex';
        document.getElementById('continue-yes').onclick = () => {
          overlay.style.display = 'none';
          // cargar la temporada y episodio guardado
          fetchSeasonEpisodes(lastObj.season, lastObj.episode, Number(lastObj.time));
        };
        document.getElementById('continue-no').onclick = () => {
          overlay.style.display = 'none';
          // cargar la primera temporada por defecto
          if (firstSeason !== null) {
            select.value = firstSeason;
            fetchSeasonEpisodes(firstSeason);
          }
        };
        return; // no auto-cargar la primera temporada hasta que el usuario elija
      }
    }
  } catch(e){
    console.warn('Error leyendo last watched:', e);
  }

  // Si no hay progreso guardado, cargar automáticamente la primera temporada
  if (firstSeason !== null) {
    select.value = firstSeason;
    fetchSeasonEpisodes(firstSeason);
  }
}

/* fetchSeasonEpisodes: acepta opcionales targetEpisode (para cargar episodio específico)
   y startAt (segundos) para arrancar desde un tiempo dado.
*/
async function fetchSeasonEpisodes(seasonNumber, targetEpisodeNumber = null, startAt = 0) {
  try {
    const res = await fetch(`https://api.themoviedb.org/3/tv/${serieId}/season/${seasonNumber}?api_key=${TMDB_API_KEY}&language=es-ES`);
    const season = await res.json();
    renderEpisodes(season);

    // Si se pidió un episodio concreto, cargarlo; si no, cargar el primer episodio
    if (targetEpisodeNumber != null) {
      const targetEp = (season.episodes || []).find(e => Number(e.episode_number) === Number(targetEpisodeNumber));
      if (targetEp) {
        loadEpisode(season.season_number, targetEp.episode_number, targetEp, startAt);
        return;
      }
    }

    if (season.episodes && season.episodes.length > 0) {
      const firstEp = season.episodes[0];
      loadEpisode(season.season_number, firstEp.episode_number, firstEp);
    }
  } catch (e) {
    console.error('Error cargando temporada:', e);
  }
}

function renderEpisodes(season) {
  const episodesDiv = document.getElementById('episodes');
  episodesDiv.innerHTML = '';

  (season.episodes || []).forEach(ep => {
    const epDiv = document.createElement('div');
    epDiv.className = 'episode-card';
    epDiv.innerHTML = `
      <img src="${ep.still_path ? imageBase + ep.still_path : ''}" alt="${ep.name}">
      <h4>${ep.episode_number}. ${ep.name}</h4>
    `;
    epDiv.addEventListener('click', () => loadEpisode(season.season_number, ep.episode_number, ep));
    episodesDiv.appendChild(epDiv);
  });
}

/* loadEpisode: ahora acepta startAt (segundos) opcional para reanudar.
   También guarda progreso (throttled cada 5s), guarda 'last watched' y maneja overlay
   si existe progreso específico para ese episodio.
*/
function loadEpisode(seasonNum, episodeNum, ep, startAt = 0) {
  const serie = seriesData[serieId];
  const videoUrl = serie && serie[seasonNum] && serie[seasonNum][episodeNum];
  if (!videoUrl) {
    console.warn("No hay enlace configurado para este episodio en series.json");
    // Aún así, podemos inicializar jwplayer con un archivo vacío para mantener UI si se desea,
    // pero por ahora solo salimos para no romper.
    return;
  }

  currentEpisodeKey = `${serieId}-S${seasonNum}-E${episodeNum}`;

  // Si ya hay un player existente, remove listeners by recreating element (safer)
  // (Esto evita que múltiples instancias interfieran)
  try {
    // eliminar instancia previa si existe
    if (playerInstance && typeof playerInstance.remove === 'function') {
      playerInstance.remove();
    }
  } catch(e){ /* ignorar */ }

  // Aseguramos que el contenedor esté limpio
  const playerEl = document.getElementById('myPlayer');
  playerEl.innerHTML = '';

  playerInstance = jwplayer("myPlayer").setup({
    file: videoUrl,
    image: ep.still_path ? imageBase + ep.still_path : '',
    autostart: false,
    width: "100%",
    aspectratio: "16:9",
    type: detectType(videoUrl),
    skin: { name: "netflix" }
  });

  // Si se solicita iniciar desde un tiempo, esperar a 'ready' y 'playback' para hacer seek
  if (startAt && Number(startAt) > 0) {
    playerInstance.on('ready', () => {
      // algunos players requieren un pequeño delay antes del seek en ciertos sources
      setTimeout(() => {
        try { playerInstance.seek(Number(startAt)); } catch(e){}
      }, 250);
    });
    // arrancar reproducción tras el seek cuando el usuario haya pedido "continuar":
    playerInstance.on('play', function(){/* no-op */});
  }

  // Si hay progreso guardado para este episodio, preguntar si desea continuar (umbral 5s)
  try {
    const saved = localStorage.getItem(currentEpisodeKey);
    const savedTime = saved ? Number(saved) : 0;
    const overlay = document.getElementById('continue-overlay');
    const text = document.getElementById('continue-text');

    if (savedTime && savedTime > 5 && (!startAt || Number(startAt) === 0)) {
      // mostrar overlay específico para este episodio
      text.textContent = `¿Deseas continuar este episodio desde ${formatTime(savedTime)}?`;
      overlay.style.display = 'flex';

      document.getElementById('continue-yes').onclick = () => {
        overlay.style.display = 'none';
        // seek y play cuando esté listo
        playerInstance.on('ready', () => {
          setTimeout(()=> {
            try { playerInstance.seek(savedTime); } catch(e){}
            try { playerInstance.play(); } catch(e){}
          }, 250);
        });
      };

      document.getElementById('continue-no').onclick = () => {
        overlay.style.display = 'none';
        // Empezar desde 0
        playerInstance.on('ready', () => {
          try { playerInstance.seek(0); } catch(e){}
          try { playerInstance.play(); } catch(e){}
        });
      };
    }
  } catch(e){
    console.warn('Error comprobando progreso episodio:', e);
  }

  // Guardar progreso con throttle (cada >=5s)
  let lastSavedAt = 0;
  playerInstance.on('time', e => {
    const pos = Number(e.position || 0);
    if (!isFinite(pos)) return;
    // guardar cada 5 segundos
    if (pos - lastSavedAt >= 5) {
      try {
        localStorage.setItem(currentEpisodeKey, String(pos));
        // además actualizar "last watched" global de la serie
        localStorage.setItem(`${serieId}-last`, JSON.stringify({ season: seasonNum, episode: episodeNum, time: pos }));
        lastSavedAt = pos;
        lastSavedPosition = pos;
      } catch(err) {
        console.warn('No se pudo guardar progreso:', err);
      }
    }
  });

  // También guardar en pausas y cambios de estado por si acaso
  playerInstance.on('pause', () => {
    saveCurrentProgress();
  });

  // Al terminar, eliminar progreso de este episodio (opcional comportamiento)
  playerInstance.on('complete', () => {
    try {
      localStorage.removeItem(currentEpisodeKey);
      localStorage.removeItem(`${serieId}-last`);
    } catch(e){}
  });
}

/* Guardado de emergencia: intenta obtener posición actual del player y guardarla */
function saveCurrentProgress(){
  try {
    if (!currentEpisodeKey) return;
    let pos = lastSavedPosition;
    if (playerInstance) {
      // preferimos getPosition() si existe
      if (typeof playerInstance.getPosition === 'function') {
        try {
          const p = playerInstance.getPosition();
          if (isFinite(p)) pos = p;
        } catch(e) { /* fallback a lastSavedPosition */ }
      }
    }
    if (pos && isFinite(pos)) {
      localStorage.setItem(currentEpisodeKey, String(pos));
      // actualizar last watched global
      // parse currentEpisodeKey para extraer season y episode
      try {
        const m = currentEpisodeKey.match(/-S(\d+)-E(\d+)$/);
        if (m) {
          const season = Number(m[1]), episode = Number(m[2]);
          localStorage.setItem(`${serieId}-last`, JSON.stringify({ season, episode, time: pos }));
        }
      } catch(e){}
    }
  } catch(e){
    console.warn('Error en saveCurrentProgress:', e);
  }
}

// Guardar al salir / ocultar pestaña
window.addEventListener('beforeunload', saveCurrentProgress);
document.addEventListener('visibilitychange', () => {
  if (document.visibilityState === 'hidden') saveCurrentProgress();
});

/* detecta tipo por extensión */
function detectType(url) {
  if (!url) return 'mp4';
  if (url.endsWith('.m3u8')) return 'hls';
  if (url.endsWith('.mpd')) return 'dash';
  if (url.endsWith('.webm')) return 'webm';
  if (url.endsWith('.mkv')) return 'mp4';
  return 'mp4';
}

/* Iniciar */
fetchSerieInfo();
</script>

<style>
    
    
 

:root{
  --header-h:70px;
  --info-h:180px;
  --player-h:auto;
}
*{box-sizing:border-box}
html,body{height:100%;margin:0;font-family:"Segoe UI",Arial,sans-serif;background:#000;color:#fff;overflow:hidden;}
body::before{
  content:"";position:fixed;inset:0;background:rgba(0,0,0,0.65);backdrop-filter:blur(8px);z-index:0;
}
.site-header{
  position:fixed;top:0;left:0;right:0;
  height:var(--header-h);display:flex;align-items:center;justify-content:center;
  gap:1rem;padding:0 1rem;background:rgba(17,17,17,0.95);z-index:1200;
  border-bottom:1px solid rgba(255,255,255,0.03);
}
.site-header .back{position:absolute;left:12px;top:50%;transform:translateY(-50%);color:#fff;text-decoration:none;font-size:.7rem;}
.site-header h1{margin:0;font-size:.7rem;}
.serie-container{max-width:1100px;margin:0 auto;padding:20px;position:relative;z-index:1;}
.serie-info{
  position:fixed;top:calc(var(--header-h)+8px);left:50%;transform:translateX(-50%);
  width:calc(100% - 40px);max-width:1100px;height:var(--info-h);z-index:1100;
  background:rgba(0,0,0,0.55);border-radius:10px;padding:12px;display:flex;align-items:center;gap:16px;overflow:hidden;
}
.info-overlay{display:flex;align-items:center;gap:16px;width:100%}
.poster{width:130px;border-radius:8px;flex:0 0 auto;box-shadow:0 6px 18px rgba(0,0,0,0.8)}
.details{flex:1;min-width:0}
.details h1{margin:0 0 6px 0;font-size:.6rem}
.rating-wrapper{margin:4px 0;display:flex;align-items:center}
.tagline{font-style:italic;color:#ccc;margin:6px 0}
.overview{max-height:56px;overflow:hidden;font-size:0.3rem;color:#ddd;opacity:0.95}
.player-wrapper{
  position:fixed;
  top:calc(var(--header-h) + var(--info-h) + 14px);
  left:50%;transform:translateX(-50%);
  width:min(100%,980px);
  z-index:1090;
  border-radius:10px;
  background:rgba(0,0,0,0.6);
  padding:6px;
}
.player-container{width:100%;border-radius:8px;overflow:hidden;background:#000;}
.bottom-panel{
  position:fixed;
  bottom:36px;
  left:50%;
  transform:translateX(-50%);
  width:calc(100% - 40px);
  max-width:1100px;
  background:rgba(0,0,0,0.45);
  border-radius:10px;
  padding:14px;
  z-index:1080;
}
.season-selector{text-align:center;margin:8px 0}
#seasonSelect{padding:.6em;border-radius:6px;border:none;font-size:1em}
.scrollable-list{max-height:200px;overflow-y:auto;padding-right:6px;margin-top:8px;}
.scrollable-list::-webkit-scrollbar{width:8px}
.scrollable-list::-webkit-scrollbar-thumb{background:rgba(0,255,127,0.15);border-radius:6px}
.episodes{display:grid;grid-template-columns:repeat(auto-fill,minmax(160px,1fr));gap:12px;}
.episode-card{background:#111;border-radius:10px;overflow:hidden;cursor:pointer;transition:transform .15s,background .15s}
.episode-card:hover{transform:translateY(-4px)}
.episode-card img{width:100%;display:block;height:110px;object-fit:cover}
.episode-card h4{padding:.6em;font-size:.9em;text-align:center;margin:0}
.site-footer{
  position:fixed;left:0;right:0;bottom:0;height:36px;
  display:flex;align-items:center;justify-content:center;background:rgba(17,17,17,0.95);
  z-index:1200;font-size:0.6rem;border-top:1px solid rgba(255,255,255,0.03)
}

/* círculo de rating más pequeño */
.rating-circle{position:relative;width:30px;height:30px}
.rating-circle svg{position:absolute;top:0;left:0;width:30px;height:30px;transform:rotate(-90deg)}
.rating-circle circle{fill:none;stroke-width:3;stroke-linecap:round}
.rating-circle circle.bg{stroke:rgba(255,255,255,0.14)}
.rating-circle circle.progress{stroke:#00ff7f;stroke-dasharray:80;stroke-dashoffset:80;animation:fillProgress 1.3s ease forwards}
@keyframes fillProgress{to{stroke-dashoffset:var(--offset,0)}}
.rating-circle span{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);font-weight:bold;color:#fff;font-size:0.6rem}

/* Responsive */
@media(max-width:1000px){
  .poster{width:120px}
  .episode-card img{height:100px}
}
@media(max-width:700px){
  .poster{width:110px}
  .player-wrapper{width:calc(100% - 28px);}
  .scrollable-list{max-height:160px}
  .episode-card img{height:90px}
  .details h1{font-size:.3rem}
}
 .site-header {
    display: none;
  }
</style>
</body>
</html>
